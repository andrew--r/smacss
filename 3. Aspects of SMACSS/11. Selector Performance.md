# Производительность селекторов
В моей работе мне часто приходится исследовать производительность. Мы используем некоторое количество инструментов для поиска слабых мест нашего приложения. Одним из этих инструментов является [Google Page Speed](http://code.google.com/speed/page-speed). Этот инструмент предоставляет рекомендации по улучшению JavaScript и по увеличению скорости отрисовки страницы. Перед тем как мы погрузимся в эти рекомендации, нам потребуется понять, как браузеры обрабатывает CSS.

## Как обрабатывается CSS
### Стиль элемента обрабатывается при создании элемента
Мы часто думаем о наших страницах, как о полных и завершённых документах, наполненных контентом. Однако браузеры спроектированы так, что они обрабатывают документ как поток. Они начинают получение документа с сервера и они могут отрисовать его ещё до того, как он окончательно загрузится. Каждый DOM-узел обрабатывается и отрисовывается сразу после того, как он будет загружен.

```html
<!-- Пример HTML-документа -->
<body>
   <div id="content">
      <div class="module intro">
         <p>Lorem Ipsum</p>
      </div>
      <div class="module">
         <p>Lorem Ipsum</p>
         <p>Lorem Ipsum</p>
         <p>Lorem Ipsum <span>Test</span></p>
      </div>
   </div>
</body>
```

Браузер начинает с верха и видит элемент `body`. В этой точке он думает, что этот элемент пустой. Он ещё не обработал ничего другого. Браузер определит вычисленные стили и применит их к элементу. Какой нужен шрифт, цвет, высота строки? После того, как он определит всё это, он отрисует элемент на экране.

Далее браузер видит элемент `div` с идентификатором `content`. Он снова думает, что данный элемент пуст. Он так же не обработал ничего другого. Браузер определяет стили, и `div` отрисовывается. Браузер также определит, требуется ли перерисовать `body` — стал ли этот элемент шире или выше? (Есть и другие вещи, влияющие на отрисовку, но изменение высоты или ширины — это основные причины перерисовки родительских элементов).

Этот процесс продолжается до тех пор, пока браузер не достигнет конца документа.

Если хотите пронаблюдать визуализацию процесса перерасчета DOM-дерева / перерисовки страницы в браузере Firefox, посетите [http://youtu.be/ZTnIxIA5KGw](http://youtu.be/ZTnIxIA5KGw).

### CSS обрабатывается справа налево
Чтобы определить, к каким конкретно элементам применить стили, браузер начинает обработку с правого края селектора и движется влево.

Если у вас есть блок правил вроде `body div#content p { color: #003366; }`, то браузер проверит все элементы на странице на то, являются ли они элементом `p`. Если являются, то он продолжит поиск по родительским элементам — являются ли они элементом `div` с идентификатором `content`. Если он найдёт совпадения, он так же продолжит поиск следующих родителей, пока не дойдёт до `body`.

С помощью обработки справа налево браузер может быстрее определить, какие стили применяются к конкретному элементу, который должен быть отрисован на странице. Чтобы определить, какой селектор более или менее производителен, вам треубется понять, сколько узлов DOM должны быть обработаны перед применением стилей к элементу.

## Какие правила правят?
Так как каждый элемент должен быть отрисован, браузеру нужно понять, какие стили применять к определённым элементам. Давайте взглянем на [рекомендации](http://code.google.com/speed/page-speed/docs/rendering.html#UseEfficientCSSSelectors) Google Page Speed. Есть четыре основных типа правил, которые признаны неэффективными:

* Правила с дочерними селекторами, например `#content h3`
* Правила с селекторами по потомкам первого уровня, например `#content > h3`
* Правила c перегруженными селекторами, например `div#content > h3`
* Правила, применяющие `:hover` не к ссылкам, например `div#content:hover`

Из этих рекомендаций можно сделать вывод о том, что обработка более чем одного элемента для применения стилей является неэффективной. Это значит, что вы можете использовать только простой одиночный селектор по классу, идентификатору, элементу или атрибуту. Если беспрекословно выполнять эти рекомендации, то мы вернёмся назад в дни, когда присваивание класса к каждому абзацу текста было нормой (`<p class="bodytext"></p>`). (И если вы посмотрите на CSS продуктов вроде поиска или почты Google, вы поймёте, что они следуют этим рекомендациям).

##
Я верю, что большинство из нас будут немного более практичными и сумеют сохранить баланс между добавлением классов/идентификаторов и использованием многоуровневых селекторов, крепко связывающих HTML и CSS.

Я следую трём простым правилам, помогающим ограничить количество обрабатываемых браузером элементов:

1. Используйте дочерние селекторы
2. Ограничьте использование селекторов по имени тега для основных элементов
3. В конце селектора используйте имя класса

Например, `.module h3` может быть неплохим решением только в том случае, когда на странице имеется лишь небольшое количество заголовков `h3`. Как глубоко эти заголовки расположены в DOM? Возможно они имеют четыре уровня вложенности (`html > body > #content > h3`), или же они имеют десять уровней вложенности (`html > body > #content > div > div > … > h3`)? Могу ли я ограничить обработку DOM с помощью дочерних селекторов? Если я напишу `.module > h3` (прости, IE6), то я буду знать, что для стилизации двенадцати заголовков браузеру потребуется обработать их 24 раза. Если же я напишу `.module div`, и при этом на странице будет 900 `div`'ов (например, я открыл свою почтовый ящик Yahoo!, а в нём 903 `div`'а) — в таком случае браузеру придётся обрабатывать страницу намного дольше. Простая разметка `<div><div><div></div></div></div>` (3 уровня вложенности) будет обработана за 6 раз. Это факториал. Четыре уровня вложенности будут обработаны за 24 раза. Пять уровней вложенности обрабатываются за 120 раз.

Подытожим всё вышесказанное. Даже простые оптимизации могут оказаться излишеством. Стив Саудерс (он много работает над тестированием производительности) исследовал влияние CSS-селекторов на производительность и определил, что разница между лучшим и худшим результатом была всего лишь в 50 миллисекунд. Другими словами, учитывайте производительность селекторов, но не тратьте на оптимизацию слишком много времени.
