# Правила вёрстки
CSS по своей природе используется для расположения элементов на странице. Существует разница между основными и второстепенными компонентами страницы. Второстепенные компоненты, такие как всплывающие подсказки, формы входа или пункты меню, располагаются внутри основных компонентов, таких как шапка или подвал. Я называю второстепенные компоненты модулями — о них мы поговорим в следующей главе. Основные компоненты я называю стилями вёрстки.

Cтили вёрстки также могут делиться на основные и второстепенные стили на основе их повторного использования. Основные стили вёрстки — например, для шапки и подвала — традиционно определяются при помощи идентификаторов, но стоит потратить время на то, чтобы подумать об элементах, которые являются общими для всех компонентов страницы, и использовать для них классы.

```css
/* Объявление стилей вёрстки */
#header, #article, #footer {
  width: 960px;
  margin: auto;
}

#article {
  border: solid #CCC;
  border-width: 1px 0 0;
}
```

Некоторые сайты требуют более обобщенного в плане разметки фреймфорка (например, [960.gs](http://960.gs)). В этом случае стили вёрстки будут заданы через классы, а не идентификаторы, поэтому эти стили можно будет использовать в любом месте страницы. 

Обычно стили вёрстки обозначены одним селектором: либо идентификатором, либо единственным классом. Тем не менее, бывают моменты, когда вёрстка должна реагировать на различные факторы. Например, у вас может быть разная вёрстка в зависимости от настроек пользователя. Такие настройки должны быть объявлены в виде стилей вёрстки, и использоваться они должны вместе с другими стилями вёрстки.

```css
/* Использование стилей вёрстки более высокого уровня в сочетании с остальными стилями вёрстки */
#article {
  float: left;
}

#sidebar {
  float: right;
}

.l-flipped #article {
  float: right;
}

.l-flipped #sidebar {
  float: left;
}
```

В данном примере вёрстки класс `.l-flipped` применяется к элементу более высокого уровня, такому как `body`, и позволяет элементам `#article` и `#sidebar` менять своё положение — `#sidebar` перемещается из правой части в левую, а `#article` наоборот.

*пример с заголовком "Исползование двух стилей Разметки одновременно для переключения с резиновой разметки на разметку с фиксированной шириной"
```css
/* Использование двух стилей вёрстки вместе для переключения между резиновой и фиксированной вёрсткой */
#article {
  width: 80%;
  float: left;
}

#sidebar {
  width: 20%;
  float: right;
}

.l-fixed #article {
  width: 600px;
}

.l-fixed #sidebar {
  width: 200px;
}
```

В этом примере класс `.l-fixed` модифицирует дизайн для изменения вёрстки с резиновой (ширина задана в процентах) на фиксированную (ширина задана в пикселях).

Также в этих примерах стоит обратить внимание на соглашение по именованию, которое я использовал. Объявления, использующие идентификатор, именуются без всяких разделений — так, как есть. А вот селекторы по классам *используют* префикс `l-`. Это помогает легко отличить назначение этих стилей и отделить их от стилей модулей и состояний. Стили вёрстки — единственная категория, в которой можно использовать идентификаторы, если вы вообще собираетесь их использовать. Если вы хотите использовать разделители в идентификаторах — используйте, но это не так уж и необходимо.

#### Использование селекторов по идентификатору
Честно говоря, использование идентификаторов в вашей разметке может быть хорошей штукой, а в некоторых случаях и абсолютно необходимой. Например, идентификаторы могут эффективно взаимодействовать с JavaScript. Однако в CSS в плане производительности нет разницы между идентификаторами и классами. Классы могут разве что только увеличить специфичность и, как следствие, сделать стилизацию более сложной.

#### Примеры вёрстки
Одно дело теория, другое дело — работающее приложение. Давайте взглянем на действующий сайт и разберемся, что относится к вёрстке, а что — к модулям.

![](http://smacss.com/img/lyt-cnn0.png)

На сайте CNN можно увидеть несколько довольно распространённых шаблонов. Это шапка, главное меню, область контента и подвал (не виден на скриншоте).

![](http://smacss.com/img/lyt-cnn1.png)

На момент написания этих строк сайт соответствовал этой схеме. На сайте использовались идентификаторы для основных секций.

```css
/* Наша структура CSS может выглядеть примерно так: */
#header { … }
#primarynav { … }
#maincontent { … }
```

```html
<div id="header"></div>
<div id="primarynav"></div>
<div id="maincontent"></div>
```

Это довольно очевидно, и я уверен, что вы думаете «Серьезно? Вы пытаетесь научить меня этому?!». Давайте посмотрим на другую часть страницы.

![](http://smacss.com/img/lyt-cnn-ft0.png)

В разделе «Featured» мы видим сетку новостей. На данный момент верстка сайта CNN представляет собой контейнер `div` с дочерними блоками `div`. Я бы скорее использовал в этом случае ненумерованный список, так что давайте так и сделаем.

```html
<!-- Пример разметки для секции «Featured» -->
<div>
<h2>Featured</h2>
<ul>
  <li><a href="…">…</a></li>
  <li><a href="…">…</a></li>
  …
</ul>
</div>
```

Без применения подхода SMACSS мы бы, вероятно, присвоили контейнеру идентификатор `featured` и далее стилизовали бы внутренний контент.

```css
/* Возможный подход к стилизации ленты новостей */
div#featured ul { 
  margin: 0;
  padding: 0;
  list-style-type: none;
}

div#featured li {
  float: left;
  height: 100px;
  margin-left: 10px;
}
```

Используя такой подход мы предполагаем следующее:

1. На странице будет только один раздел «Featured»
2. Элементы списка выравниваются по левому краю
3. Элементы списка имеют высоту в `100px`

Эти допущения могут быть вполне обоснованными. Это классический пример небольшого сайта, который так и останется с такой структурой: вряд ли он будет меняться и становиться сложнее. Более крупные сайты с большей вероятностью будут меняться, а значит с большей вероятностью придётся провести рефакторинг и переработку такого кода.

Вспомним предыдущий пример — в нём определённо есть что улучшить. Селектор по идентификатору не требует уточнения с помощью добавления тега `div`. Кроме того, так как список является прямым потомком `div`, можно использовать дочерний селектор (`>`).

Давайте посмотрим, как мы можем переработать код, чтобы добиться большей гибкости.

Всё, что нас будет беспокоить со стороны вёрстки — это положение блоков друг относительно друга. Нас не должен заботить ни дизайн модулей, ни контекст, в котором они находятся.

```css
/* Модуль сетки, примененный к OL или UL */

.l-grid {
  margin: 0;
  padding: 0;
  list-style-type: none;
}

.l-grid > li {
  display: inline-block;
  margin: 0 0 10px 10px; 
    
  /* IE7-хак для имитации inline-block*/
  *display: inline;
  *zoom: 1;
}
```

Какие же проблемы мы решили, применив такой подход, и какие проблемы мы создали? (Крайне редко какой-либо подход решает 100% задачи).

1. Класс сетки теперь может быть применён к любому блоку для создания float-подобной вёрстки.
2. Мы уменьшили *глубину применимости* до 1 (подробнее об этом в главе «Глубина применимости»)
3. Мы уменьшили специфичность селекторов
4. Требования к высоте были убраны. Теперь отдельная строка будет иметь высоту самого высокого элемента в ней.

С другой стороны, как мы ухудшили ситуацию?

1. Используя дочерний селектор, мы отказываемся от поддержки IE6 (но мы можем обойти эту проблему, ограничив использование дочернего селектора).
2. Размер и сложность CSS-файла увеличились.

Увеличение CSS-файла — спорный вопрос, но он незначителен. Теперь у нас есть универсальный для использования модуль и мы может применять его повсеместно, не дублируя код. Увеличение сложности также не имеет большого значения. Нам уже приходилось верстать под устаревшие браузеры и использовать хаки, которые, вероятно, у кого-то вызывали недовольство. Однако, селекторы не так сложны, что позволяет нам расширить область применения такой верстки, всё ещё избавляясь от влияния специфичности.