# Изменение состояния.
Допустим у вас есть макет и вам надо его сверстать.

Он может показаться вам достаточно простым, чтобы сразу начать переносить макет в код. Тем не менее, различные компоненты на странице могут иметь несколько состояний: по умолчанию и при изменном состоянии.

## Что такое изменение состояния?
Изменения состояния может быть представлено тремя вариантами:

1. имя класса
2. псевдокласс
3. медиа-запрос

Изменение класса происходит из js по возникновению некоторого события(будь то наведение мышкой на что-то или нажатие клавиши на клавиатуры и т.д). Элемент получает новый класс и новое представление.

Изменение псевдокласса выполняется благодаря любому числу псевдоклассов. В этом случае мы не полагаемся на js. Этот способ по прежнему ограничен примением классов только к самому элементу, детям или соседям текущему элементу.

Наконец медиа-запросы описывает стили на различных размерах окна.

В случае использования модульной системы важно рассмотреть состояние применимое к каждому модулю по умолчанию. Когда вы зададите себе вопрос "что такое состояние по умолчанию", ваше мышление выйдет на новый уровень. Ваш подход станет капельку другим.

## Изменение с помощью класса

По больше части очень просто, например: пользователь нажал на иконку, чтобы скрыть другой элемент.
```javascript
// with jQuery
$('.btn-close').click(function(){ 
    $(this).parents('.dialog').addClass('is-hidden');        
})
```
Пример с jQuery вешает обработчик на клик каждому элементу с классом `.btn-close`, который должен искать среди родителей элемент с классом .dialog и добавлять ему класс .is-hidden.

 __От переводчика__: _на самом деле он найдет все `.dialog` выше текущего элемента. Так работает parents. Т.е в структуре_

`.dialog>.dialog>.dialog>.btn-close` 

`$(".btn-close").parents(".dialog").length == 3` — _поведение наверняка неожидаемое. Метод closest будет искать ближайшего родителя с классом `.dialog.`_

В других случаях, изменение состояния может делать большИе изменения.

Оснавная идея, что нажатие кнопки будет показывать меню. В этом случае кнопка меняет состояние на нажатое, а меню меняет свое состояние-отображение. Какие варианты у нас есть для реализации этих изменений? Это зависит в значительной степени от html структуры. Например, у нас в Yahoo меню загружается во время запроса и вставляется в верхней части DOM. Мы использовали соглашение имен, чтобы подключить два вместе**(*1)**.

__(*1)__ Вероятнее всего имеется ввиду соотвествие data-action с id меню.
```html
<div id="content">
   <div class="toolbar">
      <button id="btn-new" class="btn" data-action="menu">New</button>
   </div>
</div>
<div id="menu-new" class="menu">
   <ul> ... </ul>
</div>
```
Аттрибут data-action используется в js коде по клику на кнопке и говорит: "Эй, ты хочешь загрузить меню". Код получает кнопку по id и находит соответствующее меню. Вот как это могло бы быть реализовано на jQuery:

```javascript
// bind a click handler to the button
$('#btn-new').click(function(){
    // wrap the clicked button in jQuery
    var el = $(this); 

    // change the state of the button
    el.addClass('is-pressed');

    // find the menu by stripping btn- and
    // adding it to menu selector
    $('#menu-' + el.id.substr(4)).removeClass('is-hidden');
});
```

Пример показывает сутиацию изменения состояния двух элементов в разных местах по одному событию.

Но что, если меню находится непосредственно рядом с кнопкой?

```html
<div id="content">
   <div class="toolbar">
      <button id="btn-new" class="btn" data-action="menu">New</button>
      <div id="menu-new" class="menu">
          <ul> ... </ul>
      </div>
   </div>
</div>
```
Предыдущий скрипт отрабатывает правильно и на этом примере, но у нас есть альтернативы. Как вариант повесить класс на родительский элемент и применить стили к вложенным:

```html
<div id="content">
   <div class="toolbar is-active">
      <button id="btn-new" class="btn" data-action="menu">New</button>
      <div id="menu-new" class="menu">
          <ul> ... </ul>
      </div>
   </div>
</div>
```

```css
.is-active .btn { color: #000; }
.is-active .menu { display: block; }
```

Проблема последнего примера в сильной привязке к html структуре. Ведь если меню не будет рядом с кнопкой, то и стили не будут применяться. Будем надеяться, что нам больше не понадобится добавлять кнопок в этот `.toolbar`

Другой подход заключается в применении класса `.is-active` к кнопке и изменении стиля меню с помощью селектора "+".

```html
<div id="content">
   <div class="toolbar">
      <button id="btn-new" class="btn is-active" data-action="menu">New</button>
      <div id="menu-new" class="menu">
          <ul> ... </ul>
      </div>
   </div>
</div>
```

```css
.btn.is-active { color: #000; }
.btn.is-active + .menu { display: block; }
```

Я предпочитаю этот подход, вместо `.is-active` на родителе, но решение попрежнему зависит от html структуры(важно, чтобы меню следовало после кнопки в разметке) и если вы можете контролировать свою разметку, то этот подход будет исправно работать.

## Почему привязка состояния к структуре проблематична.

Проблема в том, что мы не можем сразу понять, где должны быть стили, описывающие это состояние: рядом со стилями кнопки в css или стилями `.menu`?

Все, что можно сказать наличие класса-состояния к каждому будет предпочтительнее. Ведь так вы создаете лучшее разделение между вашими модулями. Сайт становится проще поддерживать и масштабировать.

## Обработка изменения состояния с помощью аттрибутов

Можно использовать селекторы аттрибутов `[data-attr='val']`, взависимости от вашей поддержки браузеров. Это может использоваться для:
1. Изолирования состояния от классов модуля и вёрстки(*категория называется слой, но в переводе, который уже есть используется "вёрстка"*)
2. Облегчения перехода между двумя состояниями


**От переводчика:** _Поддержка селекторов по атрибутам есть уже с ie8+(http://caniuse.com/#feat=css-sel2). Так же есть прикольный селектор `[name~=val]`, который ищет совпадение в списке,(и который используется в AMCSS) разделенным пробеломю Используется примерно так:_

```html
<div data-state="pressed showed"></div> 
/*И в css*/ 
div[data-state~="pressed"]{pointer-events: none}
div[data-state~="invalid"]{background: red}
``` 
*Это поможет применить два состояния одновременно. В примерах ниже применяется лишь одно состояния в аттрибутах тега.*

Давайте посмотрим на пример кнопки, которая может быть в нескольких состояниях(нажатая и не прошедшая валидацию)

Вы можете выбрать суб-модульное соглашение о наименовании состояний:

```css
.btn { color: #333; } 
.btn-pressed { color: #000; } 
.btn-disabled { opacity: .5; pointer-events: none; }
```

Если кнопка должна переключаться между двумя состояниями, то имеет смысл использовать соглашение по именованию состояния:

```css
.btn { color: #333; } 
.is-pressed { color: #000; } 
.is-disabled { opacity: .5; pointer-events: none; }
```

Мне нравится сравнение этих двух примеров, поскольку это подчеркивает, что SMACSS вносит ясность в наименования. Я был бы рад увидеть хотя бы один из этих подходов в рамках проекта. Теперь давайте посмотрим на другой вариант, состояние в аттрибутах:

```css
.btn[data-state=default] { color: #333; } 
.btn[data-state=pressed] { color: #000; } 
.btn[data-state=disabled] { opacity: .5; pointer-events: none; }
```
```html
<button class="btn" data-state="disabled">Disabled</button>
```

Префикс data- в аттрибутах это часть спецификации html5, которая позволяет создать что-то вроде namespace чтобы не конфликтовать с аттрибутами, которые будут введены в будущем в спецификацию. Изменение состояния кнопки не требует удаления\добавления классов, а просто меняет значение аттрибута.

```javascript
// bind a click handler to each button
$(".btn").bind("click", function(){
    // change the state to pressed
    $(this).attr('data-state', 'pressed');
});
```

Правда с такими js бибилиотеками как jQuery манипуляция с классами не является сложной. jQuery обеспечивает нас методами `hasClass`, `addClass` и `toggleClass`.

Вы имеете разные пути для представления состояния.

## Изменение состояния с анимацией на основе классов

Анимации интересная штука и некоторые могут подумать, что они должны быть размещены в "вёрстке"(слое) — это не правильно на самом деле. В добавок запомните: css для стилизации, js поведения.

Пусть ничего нам не мешает использовать js для изменения состояния, но важно понять, что именно css должно отвечать за визуальную составляющую. JavaScript не должен описывать стили для изменения состояния.

js используется для анимаций лишь исторически, поскольку ранее это был единственный путь.

Понимание этого поможет нам сформировать один подход для различных сценариев. Допустим элемент-сообщение. Оно будет скрыто в дефолтном состоянии(первое состояние), может появляться и спустя 3секунды плавно исчезать(второе состояние).

```javascript
function showMessage (s) {
    var el = document.getElementById('message');
    el.innerHTML = s;

    /* set state */
    el.className = 'is-visible'; 
    setTimeout(function(){
        /* set state back */
        el.className = 'is-hidden';
    }, 3000);
}
```

Состояние сообщения будет установлено в видимое и скрыто снова через 3 секунды. Js обрабатывает изменения состояния, а затем используется css для анимации.

```css
@keyframes fade {
    0% { opacity:0; display:block; }
  100% { opacity:1; display:block; }
}

.is-visible {
    display: block;
    animation: fade 2s;
}

.is-hidden {
    display: none;
    animation: fade 2s reverse;
}
```

Надо признать, что последний пример не будет работать как задумывалось. Текущая спецификация анимации не позволяет и реализация в бразуерах не позволяет указывать не анимируемые свойства. К счастью спецификация меняется и должно быть добавлено. Сейчас мы можем сделать что-то такое.

```css
@-webkit-keyframes fade {
    0% { opacity:0;  }
  100% { opacity:1; display:block; }
}

.is-visible {
    opacity: 1;
    animation: fade 2s;
}

.is-hidden {
    opacity: 0;
    animation: fade 2s reverse;
}

.is-removed {
    display: none;
}
```

```javascript
function showMessage (s) {
    var el = document.getElementById('message');
    el.innerHTML = s;

    /* set state */
    el.className = 'is-visible'; 
    setTimeout(function(){
        /* set state back */
        el.className = 'is-hidden';
        setTimeout(function(){
            el.className = 'is-removed';
        }, 2000);
    }, 3000);
}
```

В этом случае я оставил анимацию, но использовал js для удаление элемента из потока после завершения анимации.

Таким способом мы делаем разделение между стилями и поведением.

## Изменение с помощью псевдоклассов

Мы увидели, что можем использовать классы и атрибуты для обработки изменения состояния модуля. Тем не менее css предлагает нам массу псевдоклассов, которые могут помочь управлять состоянием.

В CSS2.1 три наиболее полезных псевдокласса: **:hover**, **:focus** и **:active**. CSS3 добавляет некоторое число новых псевдоклассов, большинство из которых связаны со структурой html(такие как **:nth-child** или **:last-child**). Есть так же ряд псевдоклассов CSS3, который реагируют на взаимодействие с формой(**:checked :disabled :enabled**)

По умолчанию состояние для модуля обычно определяется без псевдокласса. Определить псевдокласс как вторичное состояние модуля можно так:

```css
.btn {
    background-color: #333; /* gray */
}

.btn:hover {
    background-color: #336; /* blueish */
}

.btn:focus {
    /* blueish focus ring */
    box-shadow: 0 0 3px rgba(48,48,96,.3); 
}
```

А так же может определять подклассы для подмодулей, но это может оказаться сложным:


```css
.btn {
    background-color: #333; /* gray */
}

.btn:hover {
    background-color: #336; /* blueish */
}

.btn:focus {
    /* blueish focus ring */
    box-shadow: 0 0 3px rgba(48,48,96,.3); 
}

/* a default button state is the default choice from a
 * selection of buttons 
 */
.btn-default {
    background-color: #DEDB12; /* yellowish */
}

.btn-default:hover {
    background-color: #B8B50B; /* darker yellow */
}
/* no need to define a different focus state */
```

В последнем примере мы по сути 5 вариаций одного модуля: главный модуль, подмодуль и псевдоклассы, которые возможны. Это может оказаться еще сложнее когда мы используем вдовесок основанные на классах состояния:

```css
.btn { ... }
.btn:hover { ... }
.btn:focus { ... }

.btn-default { ... }
.btn-default:hover { ... }

.btn.is-pressed { ... }
.btn.is-pressed:hover { ... }

.btn-default.is-pressed { ... }
.btn-default.is-pressed:hover { ... }
```

К счастью, немного модулей в интерфейсе будут нуждать в таком большом списке состояний. Очевидно, что правильная организация ваших стилей даст лучшую поддержку.

## Изменение с помощью медиа-запросов

Изменение состояния с помощью классов и псевдоклассов достаточно похожи. Медиа запросы же это совершенно другой подход к управлению состоянием, который ранее был возможен лишь с помощь скриптов. Адаптивный и отзывчивый дизайн реагируют на разные критерии в запросах. Медиа-запросы для печати, первые запросы, которые позволяли определить стили странички для печати. 

Медиа-запросы могут быть для отдельного файл стилей, если использовать аттрибут media на элементе `link` или определены как @media блок внутри определнного стиля(тега, файла)

```html
<link href="main.css" rel="stylesheet">
<link href="print.css" rel="stylesheet" media="print">
```

```css
/* inside main.css */
@media screen and (max-width: 400px) {
    #content { float: none; }
}
```

Большая часть медиа-апросов устанавливают какуе-то точки и далее описывают стили, которые относят к этому разрешению внутри media-блока

В SMACSS целью является сохранить стили, которые относят к конкретному модулю рядом с остальной частью модуля. Так вместо одного @media блока описывающего все стили для определенного разрешения мы распологаем @media-блок рядом с остальным описанием модуля. Пример:

```css
/* default state for nav items */
.nav > li {
   float: left;
}

/* alternate state for nav items on small screens */
@media screen and (max-width: 400px) {
    .nav > li { float: none; }
}

... elsewhere for layout ...

/* default layout */ 
.content { 
    float: left;
    width: 75%;
}

.sidebar {
    float: right;
    width: 25%;
}

/* alternate state for layout on small screens */
@media screen and (max-width: 400px) {
    .content, .sidebar { 
        float: none;
        width: auto; 
    }
}
```

Это означает, что @media-блоки будут определены не просто несколько раз, а и то, что стили модуля будут в одном месте. Это поможет изолировать модуль для тестирования.

## Это все о состоянии

Эта глава рассматривает три типа изменения состояния: с помощью классов, псевдоклассов и медиа-запросов. Взгляд на ваш интерфейс как на модули, которые имеют различные состояния поможет вам разделить стили лучше и создавать сайты, которые будет поддерживать.